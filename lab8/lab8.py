"""by Roman Polishchenko2 course, comp mathTaras Shevchenko National University of Kyivemail: roma.vinn@gmail.com"""import copydef compare_vectors(a: list, b: list) -> bool:    """    Перевірка чи а > b (по всім координатам)    :param a: список координат    :param b: список координат    :return: True, якщо а > b, False - інакше    """    assert len(a) == len(b)    flag = True    for i in range(len(a)):        if a[i] < b[i]:            flag = False            break    return flagdef add_step(i: int, left: list, a: list, step: float, right: list, add=False) -> list:    """ Рекурсивний метод, що додає до вектора покоординатно,    починаючи з останньої координати, величину рівну step    :param i: поточна координата    :param left: список координат "лівої нижньої точки" умовного гіперкуба    :param a: список координат поточної точки    :param step: крок    :param right: список координат "правої верхньої точки" умовного гіперкуба    :param add: True, якщо вперше запускаємо функцію та додаємо крок;                False, якщо потрібно лише перевірити корректність виконаного додавання    :return: [], якщо було виконане останнє додавання;             інакше – список координат поточної точки    """    if add:        a[i] += step    if a[i] > right[i]:        if i != 0:            a[i] = left[i]            return add_step(i-1, left, a, step, right)        else:            return []    else:        return adef get_dots(dot: list, step: float) -> list:    """ Отримати координати всіх кутів та цента гіперкуба, якщо відомий лівий нижній кут    :param dot: координати лівого нижнього кута    :param step: степінь розбиття (крок)    :return: список координат потрібних точок    """    m = len(dot)    dots = [list(map(lambda x: x + step / 2, dot))]    for i in range(1, 2**m):        tmp = copy.deepcopy(dot)        num = bin(i)[2:].zfill(m)        for k in range(m):            if num[k] == '1':                tmp[k] += step        dots.append(tmp)    return dotsdef measure(func: callable, borders: tuple, n=4) -> tuple:    """ Функція для обчислення міри Жордана множини заданої функцією func, обмеженою        гіперкубом, що заданий координатами двох діаметрально протилежних точок,        записаних в borders, зі степенем розбиття n.    :param func: функція, що задає множину; повертає True, якщо точка належить множині, False – інакше    :param borders: кортеж, що містить координати двох крайніх точок    :param n: степінь розбиття    :return: внутрішня та зовнішня міри Жордана    """    left, right = borders    step = 1/2**n    curr = copy.deepcopy(left)    m = step ** len(curr)    # A^n    upper = 0    # A_n    lower = 0    while True:        curr = add_step(len(curr)-1, left, curr, step, right, add=True)        if not curr:            break        else:            flag_u = False            flag_l = True            for dot in get_dots(curr, step):                if func(dot):                    flag_u = True                else:                    flag_l = False            if flag_u:                upper += m            if flag_l:                lower += m    return lower, upperif __name__ == '__main__':    N = 2    print(measure(lambda vec: vec[0]**2 + vec[1]**2 <= 1, ([-1, -1], [1, 1]), N))    pass