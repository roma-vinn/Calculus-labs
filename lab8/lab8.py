"""by Roman Polishchenko2 course, comp mathTaras Shevchenko National University of Kyivemail: roma.vinn@gmail.com"""from copy import deepcopyfrom time import clockfrom random import uniformfrom itertools import accumulatedef add_step(i: int, left: list, a: list, step: float, right: list) -> list:    """ Рекурсивний метод, що додає до вектора покоординатно,    починаючи з останньої координати, величину рівну step    :param i: поточна координата    :param left: список координат "лівої нижньої точки" умовного гіперкуба    :param a: список координат поточної точки    :param step: крок    :param right: список координат "правої верхньої точки" умовного гіперкуба    :return: [], якщо було виконане останнє додавання;             інакше – список координат поточної точки    """    a[i] += step    if a[i] > right[i]:        if i != 0:            a[i] = left[i]            return add_step(i-1, left, a, step, right)        else:            return []    else:        return adef get_dots(dot: list, step: float) -> list:    """ Отримати координати всіх кутів та цента гіперкуба, якщо відомий лівий нижній кут    :param dot: координати лівого нижнього кута    :param step: степінь розбиття (крок)    :return: список координат потрібних точок    """    m = len(dot)    dots = [list(map(lambda x: x + step / 2, dot))]    for i in range(1, 2**m):        tmp = deepcopy(dot)        num = bin(i)[2:].zfill(m)        for k in range(m):            if num[k] == '1':                tmp[k] += step        dots.append(tmp)    return dotsdef measure(array: callable, borders: tuple, n=4) -> tuple:    """ Функція для обчислення міри Жордана множини заданої функцією func, обмеженою        гіперкубом, що заданий координатами двох діаметрально протилежних точок,        записаних в borders, зі степенем розбиття n.    :param array: функція, що задає множину; повертає True, якщо точка належить множині, False – інакше    :param borders: кортеж, що містить координати двох крайніх точок    :param n: степінь розбиття    :return: внутрішня та зовнішня міри Жордана, помилка    """    left, right = borders    step = 1/2**n    curr = deepcopy(left)    m = step ** len(curr)    # A^n    upper = 0    # A_n    lower = 0    while True:        curr = add_step(len(curr)-1, left, curr, step, right)        if not curr:            break        else:            flag_u = False            flag_l = True            for dot in get_dots(curr, step):                if array(dot):                    flag_u = True                else:                    flag_l = False            if flag_u:                upper += m            if flag_l:                lower += m    error = upper - lower    return lower, upper, errordef measure_monte_carlo(array: callable, borders: tuple, n=100) -> float:    """ Функція для обчислення міри Жордана методом Монте-Карло множини заданої        функцією func, обмеженою гіперкубом, що заданий координатами двох        діаметрально протилежних точок, записаних в borders, де n - к-сть обраних точок.    :param array: функція, що задає множину; повертає True, якщо точка належить множині, False – інакше    :param borders: кортеж, що містить координати двох крайніх точок    :param n: степінь розбиття    :return: внутрішня та зовнішня міри Жордана, помилка    """    inside = 0    borders = list(zip(borders[0], borders[1]))    mes = map(lambda x: abs(x[0] - x[1]), borders)    mes = list(accumulate(mes, lambda x, y: x * y))[-1]    for i in range(n):        dot = list(map(lambda x: uniform(x[0], x[1]), borders))        if array(dot):            inside += 1    mes *= inside/n    return mesdef integral(func: callable, array: callable, borders, n=4) -> tuple:    """ Функція для обчислення інтеграла функції func по множині array,        обмеженій гіперкубом з крайніми точками borders, де n - степінь розбиття    :param func: підінтегральна функція    :param array: функція, що задає множину    :param borders: границі гіперкуба, що обмежує множину    :param n: степінь розбиття    :return: інтеграл по внутрішній та зовнішній мірі Жордана, помилка    """    left, right = borders    step = 1/2**n    curr = deepcopy(left)    m = step ** len(curr)    upper_m = 0    upper_f = 0    lower_m = 0    lower_f = 0    sup = abs(func(borders[0]))    while True:        curr = add_step(len(curr)-1, left, curr, step, right)        if not curr:            break        else:            flag_u = False            flag_l = True            for dot in get_dots(curr, step):                if array(dot):                    flag_u = True                else:                    flag_l = False            f_psi = func(list(map(lambda x: x + step / 2, curr)))            sup = max(abs(f_psi), sup)            if flag_u:                upper_m += m                upper_f += f_psi            if flag_l:                lower_m += m                lower_f += f_psi    lower = lower_f * lower_m    upper = upper_f * upper_m    error = (upper_m - lower_m) * sup    return lower, upper, errordef task1():    """ ВИконання першого завдання    :return: строку з форматованими вихідними даними    """    res = 'Task 1\nThe set is limited by x^4 + y^4 <= 1\n\n'    res += 'Split method:\n\n'    for N in [4, 6, 8]:        begin = clock()        l, u, e = measure(lambda vec: vec[0] ** 4 + vec[1] ** 4 <= 1, ([-1, -1], [1, 1]), N)        res += '\t n = {}\n'.format(N)        res += 'Calculated measure: {}\n'.format(l)        res += 'Error: {}\n'.format(e)        res += 'Time: {}\n\n'.format(clock() - begin)    res += 'Monte-Carlo method:\n\n'    for N in [100, 1000, 10000]:        begin = clock()        mes = measure_monte_carlo(lambda vec: vec[0] ** 4 + vec[1] ** 4 <= 1, ([-1, -1], [1, 1]), N)        res += '\t n = {}\n'.format(N)        res += 'Calculated measure: {}\n'.format(mes)        res += 'Time: {}\n\n'.format(clock() - begin)    return resif __name__ == '__main__':    with open('output.txt', 'w') as file:        print(task1(), file=file)